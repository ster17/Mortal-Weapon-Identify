<!DOCTYPE html>
<html>

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>UDW Stats Change</title>

  <style>
    body {
  font-family: Arial, sans-serif;
  background-color: #1e1e1e;
  color: #f5f5f5;
  margin: 0;
  padding: 20px;
}

.page-layout {
  display: flex;
  justify-content: center;
  align-items: flex-start;
  gap: 30px;
  max-width: 1800px;
  margin: 40px auto;
}

.side-box {
  width: 320px;
  background: #1f1f1f;
  padding: 20px;
  border-radius: 12px;
  color: #ddd;
  font-size: 0.9em;
  line-height: 1.5;
  box-shadow: 0 0 10px rgba(0, 0, 0, 0.4);
  max-height: 90vh;
  overflow-y: auto;
}

.side-box h3 {
  color: #ffd700;
  margin-top: 0;
}

.item-box {
  flex: 1;
  max-width: 700px;
  background: #222;
  padding: 15px;
  border-radius: 10px;
  text-align: center;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
}

.item-header {
  background: black;
  color: cyan;
  font-weight: bold;
  padding: 10px;
  border-radius: 10px 10px 0 0;
}

.item-image {
  width: 60px;
  height: 60px;
  margin: 10px auto;
  display: block;
  border-radius: 8px;
  border: 2px solid #ccc;
}

.option-slot {
  background: white;
  color: black;
  padding: 10px;
  margin: 5px;
  border-radius: 5px;
}

.button {
  background: cyan;
  color: black;
  font-weight: bold;
  padding: 10px;
  border: none;
  cursor: pointer;
  margin-top: 10px;
  border-radius: 5px;
}

.button:hover {
  background: lightblue;
}

.count-display {
  margin-top: 10px;
  font-weight: bold;
  color: yellow;
}

.credit {
  font-size: 12px;
  color: #aaa;
  margin-top: 20px;
  opacity: 0.8;
}

  </style>

  
</head>
<body>
  <div class="page-layout">
    
    <!-- LEFT BOX -->
    <div class="side-box">
      <h3>How to effectively roll for high score (rift server only)</h3>
      <p>For people who want to aim the highest possible option without spending the most money this is how I recommend you to roll.</p>
      <p>As you may not know, there are a total of 20 options you can get from rolling the weapon, 5 of which carry 0.8% odds per option and the rest of 16 options carry 6% odds per option. The 5 options that carry 0.8% odds are the ones that scale with enhancement level, making them harder to obtain than the rest.</p>
      <p>For that reason, you should utilize normal stat change to aim for high tier effects like 1.4%, 1.5% attack power per enhancement level or 1.4%, 1.5% all skill damage per enhancement level. These options carry the highest points within the rare options, giving you a high baseline which increases your total point after finishing the weapon with dragon lens.</p>
      <p><strong>The overall best options are:</strong><br>
        1.5% Attack Power per Enhancement Level<br>
        1.5% All Skill Damage per Enhancement Level<br>
        12% Polarize: Attack/Attacked Damage<br>
        1.5 Attack Power Level per Enhancement Level / 1.5% Critical Damage Per Enhancement Level / 12% Continuous Damage Dealt
      </p>
    </div>

    <!-- CENTER BOX -->
    <div class="item-box">
      <div class="item-header">+12 Undead Dragon's Will - Mortal Weapon</div>
      <img alt="Icon" class="item-image"
        src="https://elwiki.net/wiki/images/f/ff/HQ_Shop_Elsword_Legend_Weapon07.png" />

      <div style="font-size: 0.9em; color: lightgray;">All *enhancement effect are considered with +12</div>
      <div style="font-size: 0.9em; color: lightgray;">Max possible point is 34</div>
      <div style="font-size: 0.9em; color: lightgray;">If you use Reset Top, increase Continuous Damage points by 0.25</div>

      <div id="manual-input" class="item-box" style="margin-top:20px;">
        <div class="item-header">Manual Stat Entry</div>
        <div id="manual-stats"></div>
        <button class="button" onclick="addManualStat()">+ Add Stat</button>
        <button class="button" onclick="calculateManualStats()">Calculate Manual Score</button>
      </div>

      <div id="result">
        <div class="option-slot">No applicable effects.</div>
        <div class="option-slot">No applicable effects.</div>
        <div class="option-slot">No applicable effects.</div>
        <div class="option-slot">No applicable effects.</div>
      </div>

      <div id="reroll-counter">Re-rolls used: 0</div>
      <button class="button sticky-button" onclick="getRandomOptions()">Change Effects</button>
      <div class="count-display" id="click-count">Number of Effect Changes: 0</div>

      <button class="button" onclick="findTargetOptions()">Best In Slot Options</button>
      <button class="button" onclick="findMaxTargetOptions()">Find God Tier Options</button>

      <div id="rng-log" style="margin-top: 15px; font-size: 0.85em; color: lightgray;"></div>

      <div class="credit">
        Credit: ster - trunjthanh (discord), Lynnie - raverie (discord)
      </div>
    </div>

    <!-- RIGHT BOX -->
    <div class="side-box">
      <h3>Options and their score/odds</h3>
      <p>1.5% Attack Power per Enhancement Level - 9.5 Points - 0.8%<br><br>
        1.5% All Skill Damage per Enhancement Level - 8.5 Points - 0.8%<br><br>
        12% Polarize: Attack/Attacked Damage - 8.5 Points - 6%<br><br>
        1.5 Attack Power Level per Enhancement Level - 7.5 Points - 0.8%<br><br>
        1.5% Critical Damage Per Enhancement Level - 7.5 Points - 0.8%<br><br>
        12% Continuous Damage Dealt - 7.25 Points - 6%<br><br>
        13% Attack Power - 6.5 Points - 6%<br><br>
        13% All Skill Damage - 6 Points - 6%<br><br>
        13 Attack Level - 5.5 Points - 6%</p>
    </div>

  </div>

  <script>
    function getPointColor(score) {
    if (score <= 4) return 'green';
    else if (score <= 6) return '#d121d1';
    else if (score <= 7.5) return 'orange';
    else return 'red';
}
let rerollCount = 0;

        let clickCount = 0;
        const scoringTable = {
            "Physical/Magical Attack Power (Enhancement Level)": [[1.5, 9.5], [1.4, 9], [1.3, 8], [1.2, 7.5], [1.1, 7], [1.0, 6], [0.9, 5], [0.8, 4.5]],
            "All Skill Damage (Enhancement Level)": [[1.5, 8.5], [1.4, 8], [1.3, 7.5], [1.2, 7], [1.1, 5.5], [1.0, 5], [0.9, 5], [0.8, 4.5]],
            "Physical/Magical Attack Power Level (Enhancement Level)": [[1.5, 7.5], [1.4, 7], [1.3, 6.5], [1.2, 6], [1.1, 5.5], [1.0, 5], [0.9, 4.5], [0.8, 4]],
            "Critical Damage (Enhancement Level)": [[1.5, 7.5], [1.4, 7], [1.3, 6.5], [1.2, 6], [1.1, 5.5], [1.0, 5], [0.9, 4.5], [0.8, 4]],
            "Deals continuous damage by n% of damage dealt for 3 seconds": [[12, 7.25], [11, 6.75], [10, 6.25], [9, 5.75], [8, 5.25], [7, 4.5], [6, 4], [5, 3.5]],
            "Physical/Magical Attack Power": [[13, 7], [12, 6.5], [11, 6], [10, 5.5], [9, 5], [8, 4.5], [7, 4], [6, 3.5]],
            "Critical Damage": [[13, 5.5], [12, 5], [11, 4.5], [10, 4], [9, 3.5], [8, 3], [7, 2.5], [6, 2]],
            "Physical/Magical Attack Power Level": [[13, 5.5], [12, 5], [11, 4.5], [10, 4], [9, 3.5], [8, 3], [7, 2.5], [6, 2]],
            "Damage to Boss Monsters": [[15, 5], [14, 4.5], [13, 4.5], [12, 4], [11, 4], [10, 3.5], [9, 3], [8, 2.5]],
            "All Skill Damage": [[13, 6.5], [12, 6], [11, 5], [10, 4.5], [9, 4.5], [8, 4], [7, 3.5], [6, 3]],
            "Strength Skill Damage": [[13, 5.5], [12, 5], [11, 4.5], [10, 4], [9, 3.5], [8, 3], [7, 2.5], [6, 2]],
            "Bravery Skill Damage": [[13, 5.5], [12, 5], [11, 4.5], [10, 4], [9, 3.5], [8, 3], [7, 2.5], [6, 2]],
      	    "Polarize: Attack/Attacked Damage": [[12, 8.5], [11, 8], [10, 7], [9, 6.5], [8, 6], [7, 5.5], [6, 5], [5, 4.5]]
        };

        function calculateScore(stat, value) {
            if (!scoringTable[stat]) return 0;
            for (const [threshold, points] of scoringTable[stat]) {
                if (value >= threshold) return points;
            }
            return 0;
        }

        let searchCount = 0;

        const options = [
            ["Physical/Magical Attack Power (Enhancement Level)", 0.8, 1.5, true],
            ["Physical/Magical Attack Power Level (Enhancement Level)", 0.8, 1.5, true],
            ["Critical Damage (Enhancement Level)", 0.8, 1.5, true],
            ["All Skill Damage (Enhancement Level)", 0.8, 1.5, true],
            ["Physical/Magical Defense (Enhancement Level)", 0.8, 1.5, true],
            ["Deals continuous damage by n% of damage dealt for 3 seconds", 5, 12, false],
            ["Ignore Enemy Physical/Magical Defense", 4.5, 8, false],
            ["Physical/Magical Attack Power", 6, 13, false],
            ["Polarize: Attack/Attacked Damage", 5, 12, false],
            ["Critical Damage", 6, 13, false],
            ["Physical/Magical Attack Power Level", 6, 13, false],
            ["Physical/Magical Defense", 6, 13, false],
            ["Damage Reduction", 8, 15, false],
            ["Damage to Boss Monsters", 8, 15, false],
            ["Damage Taken from Boss Monsters", 8, 15, false],
            ["Tenacity Skill Damage", 6, 13, false],
            ["Strength Skill Damage", 6, 13, false],
            ["Bravery Skill Damage", 6, 13, false],
            ["All Skill Damage", 6, 13, false],
            ["Action Speed", 8, 15, false]
        ];

        const targetOptions = [
            "Physical/Magical Attack Power (Enhancement Level)",
            "All Skill Damage (Enhancement Level)",
            "Critical Damage (Enhancement Level)",
            "Physical/Magical Attack Power Level (Enhancement Level)",
            "Deals continuous damage by n% of damage dealt for 3 seconds",
            "Polarize: Attack/Attacked Damage"
        ];
function rollStat() {
    const enhancementStats = options.filter(o => o[0].includes("(Enhancement Level)"));
    const normalStats = options.filter(o => !o[0].includes("(Enhancement Level)"));

    // Step 1: RNG for stat selection
    let roll = Math.random() * 100;
    let chosen, rollLog = "";

    if (roll < enhancementStats.length * 0.8) {
        let idx = Math.floor(Math.random() * enhancementStats.length);
        chosen = enhancementStats[idx];
        rollLog += `Rolled ${roll.toFixed(2)} → Enhancement Stat (${chosen[0]})<br>`;
    } else {
        let idx = Math.floor(Math.random() * normalStats.length);
        chosen = normalStats[idx];
        rollLog += `Rolled ${roll.toFixed(2)} → Normal Stat (${chosen[0]})<br>`;
    }

    // Step 2: RNG for value tier (8 tiers, 12.5% each)
    const [min, max, allowDecimal] = [chosen[1], chosen[2], chosen[3]];
    let tiers = [];
    for (let i = 0; i < 8; i++) {
        tiers.push(min + i * ((max - min) / 7));
    }
    let tierIndex = Math.floor(Math.random() * 8);
    let finalValue = allowDecimal ? tiers[tierIndex].toFixed(1) : Math.round(tiers[tierIndex]);

    rollLog += `Rolled Tier Index ${tierIndex + 1}/8 → Final Value: ${finalValue}%`;

    return { name: chosen[0], value: finalValue, log: rollLog };
}


function getRandomOptions() {
    let selected = [];
    let resultDiv = document.getElementById('result');
    let rngLogDiv = document.getElementById('rng-log');
    resultDiv.innerHTML = '';
    rngLogDiv.innerHTML = '';

    while (selected.length < 4) {
        let rolled = rollStat();
        if (!selected.some(s => s.name === rolled.name)) {
            selected.push(rolled);
        }
    }

    let totalScore = 0;
    selected.forEach((opt, i) => {
    let score = calculateScore(opt.name, parseFloat(opt.value));
    totalScore += score;

    let p = document.createElement('div');
    p.className = "option-slot";
p.innerHTML = `
    <strong>${opt.name}: ${opt.value}% 
        <span style='color:${getPointColor(score)}'>(${score} pts)</span>
    </strong>
    <button class="button" onclick="rerollStat(${i})">Re-roll</button>
`;
    resultDiv.appendChild(p);

    // Append RNG details
    let logEntry = document.createElement('div');
    logEntry.innerHTML = opt.log;
    rngLogDiv.appendChild(logEntry);
});


    clickCount++;
    document.getElementById('click-count').textContent = `Number of Effect Changes: ${clickCount}`;

    let scoreDisplay = document.createElement('div');
    scoreDisplay.className = "count-display";
    scoreDisplay.textContent = `Total Score: ${totalScore} pts`;
    resultDiv.appendChild(scoreDisplay);

    let tierText = "";
    if (totalScore <= 18) tierText = "0 ~ 18 points : Re-roll";
    else if (totalScore <= 21) tierText = "19 ~ 21 points : Temporary";
    else if (totalScore <= 24) tierText = "22 ~ 24 points : Useful";
    else if (totalScore <= 29) tierText = "25 ~ 29 points : Realistic end (core modular from here on)";
    else tierText = "30 points or more : GOD";

    let tierDisplay = document.createElement('div');
    tierDisplay.className = "count-display";
    tierDisplay.textContent = tierText;
    resultDiv.appendChild(tierDisplay);
}



function findTargetOptions() {
    searchCount = 0;
    const resultDiv = document.getElementById('result');
    const rngLogDiv = document.getElementById('rng-log');
    resultDiv.innerHTML = '';
    rngLogDiv.innerHTML = '';

    while (true) {
        searchCount++;
        let selected = [];
        let logs = [];

        // Select 4 unique stats
        while (selected.length < 4) {
            const rolled = rollStat(); // Uses the enhancement-level + tier RNG
            if (!selected.some(s => s.name === rolled.name)) {
                selected.push(rolled);
                logs.push(rolled.log);
            }
        }

        // Require at least 4 target options
        let foundCount = selected.filter(opt => targetOptions.includes(opt.name)).length;
        if (foundCount >= 4) {
            let totalScore = 0;

            // Display stats and calculate total score
            selected.forEach(opt => {
                let score = calculateScore(opt.name, parseFloat(opt.value));
                totalScore += score;

                let p = document.createElement('div');
                p.className = "option-slot";
                p.innerHTML = `<strong>${opt.name}: ${opt.value}% <span style='color:${getPointColor(score)}'>(${score} pts)</span></strong>`;
                resultDiv.appendChild(p);
            });

            // Show RNG logs
            logs.forEach(l => {
                let logEntry = document.createElement('div');
                logEntry.innerHTML = l;
                rngLogDiv.appendChild(logEntry);
            });

            // ED cost and repetition count
            let edCost = searchCount * 20000000;
            document.getElementById('search-count').textContent = `Repetition Count for Desired Effects: ${searchCount}`;
            document.getElementById('ed-cost').textContent = `Required ED: ${edCost.toLocaleString()} ED`;

            // Total score display
            let scoreDisplay = document.createElement('div');
            scoreDisplay.className = "count-display";
            scoreDisplay.textContent = `Total Score: ${totalScore} pts`;
            resultDiv.appendChild(scoreDisplay);

            // Tier text
            let tierText = "";
            if (totalScore <= 18) tierText = "0 ~ 18 points : Re-roll";
            else if (totalScore <= 21) tierText = "19 ~ 21 points : Temporary";
            else if (totalScore <= 24) tierText = "22 ~ 24 points : Useful";
            else if (totalScore <= 29) tierText = "25 ~ 29 points : Realistic end (core modular from here on)";
            else tierText = "30 points or more : GOD";

            let tierDisplay = document.createElement('div');
            tierDisplay.className = "count-display";
            tierDisplay.textContent = tierText;
            resultDiv.appendChild(tierDisplay);

bestOptions.forEach((opt, i) => {
    let score = calculateScore(opt.name, parseFloat(opt.value));
    let color = getPointColor(score);

    let p = document.createElement('div');
    p.className = "option-slot";
    p.innerHTML = `
        <strong>${opt.name}: ${opt.value}% 
            <span style='color:${color}'>(${score} pts)</span>
        </strong>
        <button class="button" onclick="rerollStat(${i}, 'best')">Re-roll</button>
    `;
    bestDiv.appendChild(p);
});

            break;
        }
    }
}


       clickCount = 0;
function findMaxTargetOptions() {
    clickCount++;

    searchCount = 0;
    const MAX_ED = 100_000_000_000_000;

    const resultDiv = document.getElementById('result');
    const rngLogDiv = document.getElementById('rng-log');
    resultDiv.innerHTML = '';
    rngLogDiv.innerHTML = '';

    while (true) {
        searchCount++;
        let selected = [];
        let logs = [];

        // Select 4 unique stats using the RNG system
        while (selected.length < 4) {
            const rolled = rollStat(); // new RNG system
            if (!selected.some(s => s.name === rolled.name)) {
                selected.push(rolled);
                logs.push(rolled.log);
            }
        }

        // Count how many are target options
        let foundCount = selected.filter(opt => targetOptions.includes(opt.name)).length;

        // Calculate total score
        let totalScore = selected.reduce((sum, opt) => sum + calculateScore(opt.name, parseFloat(opt.value)), 0);

        // Check ED limit
        let edCost = searchCount * 20000000;
        if (edCost >= MAX_ED) {
            alert(`Failed to find target options within ED limit of ${MAX_ED.toLocaleString()}.\nTry again later.\nNumber of clicks: ${clickCount}\nNumber of rolls total: ${searchCount * clickCount}\nTotal ED cost: ${(clickCount * edCost).toLocaleString()} ED`);
            break;
        }

        if (foundCount >= 4 && totalScore >= 30) {
            // Display results
            selected.forEach(opt => {
                let score = calculateScore(opt.name, parseFloat(opt.value));
                let p = document.createElement('div');
                p.className = "option-slot";
                p.innerHTML = `<strong>${opt.name}: ${opt.value}% <span style='color:${getPointColor(score)}'>(${score} pts)</span></strong>`;
                resultDiv.appendChild(p);
            });

            // Display RNG logs
            logs.forEach(l => {
                let logEntry = document.createElement('div');
                logEntry.innerHTML = l;
                rngLogDiv.appendChild(logEntry);
            });

            document.getElementById('search-count').textContent = `Repetition Count for Desired Effects: ${searchCount}`;
            document.getElementById('ed-cost').textContent = `Required ED: ${edCost.toLocaleString()} ED`;

            let scoreDisplay = document.createElement('div');
            scoreDisplay.className = "count-display";
            scoreDisplay.textContent = `Total Score: ${totalScore} pts`;
            resultDiv.appendChild(scoreDisplay);

            // Tier text
            let tierText = "";
            if (totalScore <= 18) tierText = "0 ~ 18 points : Re-roll";
            else if (totalScore <= 21) tierText = "19 ~ 21 points : Temporary";
            else if (totalScore <= 24) tierText = "22 ~ 24 points : Useful";
            else if (totalScore <= 29) tierText = "25 ~ 29 points : Realistic end (core modular from here on)";
            else tierText = "30 points or more : GOD";

            let tierDisplay = document.createElement('div');
            tierDisplay.className = "count-display";
            tierDisplay.textContent = tierText;
            resultDiv.appendChild(tierDisplay);

            break;
        }
    }
}

        function applySpecialRules(stats) {
    // stats is an array of {name, value, score}
    let hasStrength = stats.some(s => s.name === "Strength Skill Damage");
    let hasBravery = stats.some(s => s.name === "Bravery Skill Damage");

    if (hasStrength && hasBravery) {
        // Remove points from Strength
        stats = stats.map(s => {
            if (s.name === "Strength Skill Damage") {
                return {...s, score: 0};
            }
            return s;
        });
    }
    return stats;
}

function addManualStat() {
    const container = document.getElementById('manual-stats');
    const currentStats = container.querySelectorAll('.manual-stat');

    if (currentStats.length >= 4) {
        alert("You can only add up to 4 stats.");
        return;
    }

    // Remove placeholder
    if (currentStats.length === 0 && container.firstChild && container.firstChild.textContent.includes("No manual stats")) {
        container.innerHTML = "";
    }

    const div = document.createElement('div');
    div.className = "option-slot manual-stat";

    div.style.display = "flex";
    div.style.alignItems = "center";
    div.style.gap = "8px";

    // Dropdown for stat selection
    const select = document.createElement('select');
    select.style.flex = "1";

    // Filter out already chosen stats
    const chosenStats = Array.from(container.querySelectorAll('select')).map(s => s.value);
    for (let opt of options) {
        if (!chosenStats.includes(opt[0])) {
            let o = document.createElement('option');
            o.value = opt[0];
            o.textContent = opt[0];
            select.appendChild(o);
        }
    }

    // Dropdown for values
    const valueSelect = document.createElement('select');
    valueSelect.style.width = "90px";
function updateManualStatOptions() {
    const container = document.getElementById('manual-stats');
    const selects = container.querySelectorAll('.manual-stat select:first-child');

    // Collect all currently selected values
    const selectedValues = Array.from(selects).map(s => s.value);

    selects.forEach(select => {
        const currentValue = select.value;
        select.innerHTML = ''; // Clear current options

        for (let opt of options) {
            if (!selectedValues.includes(opt[0]) || opt[0] === currentValue) {
                let o = document.createElement('option');
                o.value = opt[0];
                o.textContent = opt[0];
                select.appendChild(o);
            }
        }

        // Restore previous selection
        select.value = currentValue;
    });
}

function populateValues(statName) {
    valueSelect.innerHTML = "";
    const optDef = options.find(o => o[0] === statName);
    if (!optDef) return;

    const [min, max, allowDecimal] = [optDef[1], optDef[2], optDef[3]];
    let step = allowDecimal ? 0.1 : 1;

    let steps = Math.round((max - min) / step);

    for (let i = 0; i <= steps; i++) {
        let v = min + i * step;
        let option = document.createElement('option');
        option.value = allowDecimal ? v.toFixed(1) : Math.round(v);
        option.textContent = option.value;
        valueSelect.appendChild(option);
    }
}


    // Initialize values for first option
    populateValues(select.value);

    // Update values when stat changes
    select.addEventListener('change', () => {
    populateValues(select.value);
    fixDuplicateStats();   // fix any duplicates automatically
});

    // Remove button
   const removeBtn = document.createElement('button');
removeBtn.textContent = "X";
removeBtn.className = "remove-btn"; // don't use the generic .button styles here
removeBtn.onclick = () => {div.remove();
    updateManualStatOptions(); // refresh other dropdowns
};


    div.appendChild(select);
    div.appendChild(valueSelect);
    div.appendChild(removeBtn);
    container.appendChild(div);
  fixDuplicateStats();      // ensure no duplicate on first add
}
function fixDuplicateStats() {
    const container = document.getElementById('manual-stats');
    const statsDivs = container.querySelectorAll('.manual-stat');

    // Track which stats are already used
    const usedStats = new Set();

    statsDivs.forEach(div => {
        const statSelect = div.querySelector('select:first-child');
        let currentValue = statSelect.value;

        if (usedStats.has(currentValue)) {
            // Duplicate found, pick the first available stat that is not used
            const availableStat = options.find(opt => !usedStats.has(opt[0]));
            if (availableStat) {
                currentValue = availableStat[0];
                statSelect.value = currentValue;

                // Update value dropdown for the new stat
                const valueSelect = div.querySelector('select:nth-child(2)');
                const [min, max, allowDecimal] = [availableStat[1], availableStat[2], availableStat[3]];
                valueSelect.innerHTML = '';
                const step = allowDecimal ? 0.1 : 1;
                const steps = Math.round((max - min) / step);
                for (let i = 0; i <= steps; i++) {
                    let v = min + i * step;
                    const opt = document.createElement('option');
                    opt.value = allowDecimal ? v.toFixed(1) : Math.round(v);
                    opt.textContent = opt.value;
                    valueSelect.appendChild(opt);
                }
                valueSelect.value = valueSelect.options[0].value;
            }
        }

        usedStats.add(currentValue);
    });
}

function calculateManualStats() {
    const container = document.getElementById('manual-stats');
    const divs = container.querySelectorAll('.manual-stat');
    let resultDiv = document.getElementById('result');
    resultDiv.innerHTML = '';
    let totalScore = 0;

    if (divs.length === 0) {
        resultDiv.innerHTML = "<div class='option-slot'>No manual stats chosen yet.</div>";
        return;
    }

   let collected = [];

divs.forEach(d => {
    const stat = d.querySelector('select').value;
    const value = parseFloat(d.querySelectorAll('select')[1].value);
    let score = calculateScore(stat, value);
    collected.push({name: stat, value: value, score: score});
});

// Apply the Strength/Bravery filter
collected = applySpecialRules(collected);

collected.forEach(res => {
    totalScore += res.score;
    let p = document.createElement('div');
    p.className = "option-slot";
    p.innerHTML = `<strong>${res.name}: ${res.value}% <span style='color:${getPointColor(res.score)}'>(${res.score} pts)</span></strong>`;
    resultDiv.appendChild(p);
});


    let scoreDisplay = document.createElement('div');
    scoreDisplay.className = "count-display";
    scoreDisplay.textContent = `Total Score: ${totalScore} pts`;
    resultDiv.appendChild(scoreDisplay);

    let tierText = "";
    if (totalScore <= 18) tierText = "0 ~ 18 points : Re-roll";
    else if (totalScore <= 21) tierText = "19 ~ 21 points : Temporary";
    else if (totalScore <= 24) tierText = "22 ~ 24 points : Useful";
    else if (totalScore <= 29) tierText = "25 ~ 29 points : Realistic end";
    else tierText = "30 points or more : GOD";

    let tierDisplay = document.createElement('div');
    tierDisplay.className = "count-display";
    tierDisplay.textContent = tierText;
    resultDiv.appendChild(tierDisplay);
}

function rerollStat(index) {
    const resultDiv = document.getElementById('result');
    const optionSlots = resultDiv.querySelectorAll('.option-slot');

    if (index < 0 || index >= optionSlots.length) return;

    // Collect current stat names
const currentStats = Array.from(optionSlots).map(d => {
    let raw = d.querySelector('strong').textContent.split(':')[0];
    return normalizeStatName(raw);
});

const statsWithoutCurrent = currentStats.filter((_, i) => i !== index);

let newRoll;
do {
    newRoll = rollStat();
    console.log("Trying new roll:", newRoll.name);
} while (statsWithoutCurrent.includes(normalizeStatName(newRoll.name)));

    // Calculate score
    const score = calculateScore(newRoll.name, parseFloat(newRoll.value));
    const color = getPointColor(score);

    // Replace this slot’s innerHTML
    optionSlots[index].innerHTML = `
        <strong>${newRoll.name}: ${newRoll.value}% 
            <span style="color:${color}">(${score} pts)</span>
        </strong>
        <button class="button" onclick="rerollStat(${index})">Re-roll</button>
    `;

    // Update total score
    let totalScore = 0;
    optionSlots.forEach(slot => {
        const text = slot.querySelector('strong').textContent;
        const ptsMatch = text.match(/\((\d+(\.\d+)?) pts\)/);
        if (ptsMatch) totalScore += parseFloat(ptsMatch[1]);
    });

    // Update or append total score display
    let scoreDisplay = resultDiv.querySelector('.count-display');
    if (!scoreDisplay) {
        scoreDisplay = document.createElement('div');
        scoreDisplay.className = "count-display";
        resultDiv.appendChild(scoreDisplay);
    }
    scoreDisplay.textContent = `Total Score: ${totalScore} pts`;

    // Update tier text
    let tierText = "";
    if (totalScore <= 18) tierText = "0 ~ 18 points : Re-roll";
    else if (totalScore <= 21) tierText = "19 ~ 21 points : Temporary";
    else if (totalScore <= 24) tierText = "22 ~ 24 points : Useful";
    else if (totalScore <= 29) tierText = "25 ~ 29 points : Realistic end (core modular from here on)";
    else tierText = "30 points or more : GOD";

    let tierDisplay = resultDiv.querySelectorAll('.count-display')[1];
    if (!tierDisplay) {
        tierDisplay = document.createElement('div');
        tierDisplay.className = "count-display";
        resultDiv.appendChild(tierDisplay);
    }
    tierDisplay.textContent = tierText;

    // Track reroll usage
    rerollCount++;
    document.getElementById('reroll-counter').textContent = `Re-rolls used: ${rerollCount}`;
}
function normalizeStatName(name) {
    let n = name.toLowerCase().trim();
    if (n.startsWith("polarize")) return "polarize"; // group all Polarize variants
    return n;
}
  </script>
</body>
</html>
